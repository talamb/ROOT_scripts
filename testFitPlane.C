/*
 *testFitPlane.C
 *Created on: 08/01/17
 *Last Updated: 08/08/17
 *Description:
 *Test for fitPlaneWave.C
 */

#include "TArrayF.h"

#include "TRandom.h"
#include "fitPlaneWave.C"
#include "TMath.h"
#include <vector>


vector<TArrayF> predictVals(Int_t n, Float_t x_m [], Float_t y_m [], Float_t z_m [], vector<TArrayF> normCent);

//Containers used by the tree No Noise
Float_t xValsNN[2];
Float_t yValsNN[2];
Float_t zValsNN[2];

//Containers used by the tree With Noise
Float_t xValsWN[2];
Float_t yValsWN[2];
Float_t zValsWN[2];



void testFitPlane(){

//Storage for test data
Int_t numOfChannl = 200;
	Float_t x_nn[numOfChannl];
	Float_t y_nn[numOfChannl];
	Float_t z_nn[numOfChannl];

	Float_t x_wn[numOfChannl];
	Float_t y_wn[numOfChannl];
	Float_t z_wn[numOfChannl];
	Float_t time[numOfChannl];
	Bool_t useFlag[numOfChannl];

	TFile * result = new TFile("fitPlaneTest.root", "RECREATE");
	TTree * dataTree = new TTree("fitPlaneTest", "Contains the test data of fitPlaneWave.C");
	dataTree->Branch("xReg", xValsNN, "genX/F:reconX/F");
	dataTree->Branch("yReg", yValsNN, "genY/F:reconY/F");
	dataTree->Branch("zReg", zValsNN, "genZ/F:reconZ/F");

	dataTree->Branch("xNoise", xValsWN, "genX/F:reconX/F");
	dataTree->Branch("yNoise", yValsWN, "genY/F:reconY/F");
	dataTree->Branch("zNoise", zValsWN, "genZ/F:reconZ/F");

	//Used to create noise
	TRandom *interference = new TRandom();


	//Create test data without noise
	for(Int_t i = 0, j = 1; i < numOfChannl; i++){
	
		//x = 2sin(pi * j)
		x_nn[i] = 2.0f * TMath::Sin(TMath::Pi() * j);
		//y = 2cos(pi * j)
		y_nn[i] = TMath::Cos(TMath::Pi() * j) * 2.0f;
		//z = 2sin(pi * j)
		y_nn[i] = TMath::Sin(TMath::Pi() * 2.0f * j) * 2.0f;

		//currently Time is only used to create the test data
		time[i] = 1.0f * j;
		//useFlag is on for this example
		useFlag[i] = true;
	
		if(j%4 == 0){
			++j;
		}
	}


	//run fitPlaneWave
	vector<TArrayF> noNoise = fitPlaneWave(numOfChannl, x_nn, y_nn, z_nn, time, useFlag);


	//Create test data with noise
	for(Int_t i = 0, j = 1; i < numOfChannl; i++){
		Double_t interfer1 = interference->Gaus(0, 2);
		Double_t interfer2 = interference->Gaus(0, 1);
		Double_t interfer3 = interference->Gaus(0, 2);

		//x = 2sin(pi * j) +/- .2
		x_wn[i] = TMath::Sin(TMath::Pi() * j) * 2 + interfer1;
		//y = 2cos(pi * j) +/- .1	
		y_wn[i] = TMath::Cos(TMath::Pi() * j) * 2 + interfer2;
		//z = 2sin(pi * j) +/- .2	
		z_wn[i] = TMath::Sin(TMath::Pi() * j) * 2 + interfer3;
	
		//Currenly Time is only used to create the test data
		time[i] = 1.0f * j;
		if(j%4 == 0){
			++j;
		}
	}


	//run fitPlaneWave
	vector<TArrayF> Noise = fitPlaneWave(numOfChannl, x_wn, y_wn, z_wn, time, useFlag);
	vector<TArrayF> predNN = predictVals(numOfChannl, x_nn, y_nn, z_nn, noNoise);
	vector<TArrayF> predWN = predictVals(numOfChannl, x_wn, y_wn, z_wn, Noise);

	//Fill The Tree
	for(Int_t i = 0; i < numOfChannl; i++){
		//No Noise--------------------------------
		xValsNN[0] = x_nn[i];
		xValsNN[1] = predNN[0][i];
	
		yValsNN[0] = y_nn[i];
		yValsNN[1] = predNN[1][i];

		zValsNN[0] = z_nn[i];
		zValsNN[1] = predNN[2][i];
	
		//With Noise------------------------------
		xValsWN[0] = x_wn[i];
		xValsWN[1] = predWN[0][i];
		
		yValsWN[0] = y_wn[i];
		yValsWN[1] = predWN[1][i];
	
		zValsWN[0] = z_wn[i];
		zValsWN[1] = predWN[2][i];
	
		dataTree->Fill();
	}

	result->Write();
	result->Close();
	delete result;
	
}

/*====================================================================================================
 *predictedVales = takes in test data  and normal and centroid generated by fitPlaneWave 
 * and returns the predicted value from the generated planeWave
 *====================================================================================================
 */
vector<TArrayF> predictVals(Int_t n, Float_t x_m [], Float_t y_m [], Float_t z_m [], vector<TArrayF> normCent){
	vector<TArrayF> predicted;

	predicted.push_back(TArrayF(n));
	predicted.push_back(TArrayF(n));
	predicted.push_back(TArrayF(n));

	Float_t xCo = normCent[0][0];
	Float_t yCo = normCent[0][1];
	Float_t zCo = normCent[0][2];

	for(Int_t i = 0; i < n; ++i){
		//Save time calculating this once per itteration
		Double_t xComp = xCo * (x_m[i]-normCent[1][0]);
		Double_t yComp = yCo * (y_m[i]-normCent[1][1]);
		Double_t zComp = zCo * (z_m[i]-normCent[1][2]);
			
		//X Predicted value
		predicted[0][i] = normCent[1][0] - ((yComp + zComp)/ xCo);
	
		//Y Predicted value
		predicted[1][i] = normCent[1][1] - ((xComp + zComp)/ yCo);

		//Z Predicted value
		predicted[2][i] = normCent[1][2] - ((xComp + yComp)/ zCo);
	}
	return predicted;
}
